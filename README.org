* Mike Russo's Take Home Test for Fetch Rewards

** The task
#+begin_quote
You first should have users enter their name and email on a login screen. Then, you should use this information to hit our login endpoint to authenticate with our service (see API Reference below).

Once a user is successfully authenticated, they should be brought to a search page where they can browse available dogs. This page must meet the following requirements:

    Users must be able to filter by breed
    Results should be paginated
    Results should be sorted alphabetically by breed by default. Users should be able to modify this sort to be ascending or descending.
    All fields of the Dog object (except for id) must be presented in some form

Users should be able to select their favorite dogs from the search results. When finished searching, they should be able to generate a match based on dogs added to the favorites list. A single match will be generated by sending all favorited dog IDs to the /dogs/match endpoint. You should display this match however you see fit.

As for everything else, you have free rein, so get creative! We strongly encourage you to go beyond the minimum requirements to build something that showcases your strengths.

You may find it helpful to make use of a component library.
#+end_quote
Also, host it somewhere.  We will do Cloudflare.
** Breakdown
*** TODO Login page
*** TODO Main/search page
**** TODO Search input
- filter by breed
**** TODO Results area
- paginated
- alphabetically by breed, user option to change sort up or down
**** TODO Item box
All info plus checkbox to select as favorite
**** TODO Favorites area
*** TODO Its a match page/modal
*** TODO style it
*** TODO Host it
** TODO Dev log
:LOGBOOK:
CLOCK: [2025-02-03 Mon 12:07]--[2025-02-03 Mon 12:52] =>  0:45
CLOCK: [2025-02-03 Mon 11:24]--[2025-02-03 Mon 11:54] =>  0:30
CLOCK: [2025-02-03 Mon 09:24]--[2025-02-03 Mon 09:54] =>  0:30
CLOCK: [2025-02-03 Mon 08:53]--[2025-02-03 Mon 09:23] =>  0:30
:END:
Ok I have started my clock.

Plan of attack: vite and react(-router), we will keep it client side react because we have to host it.  Leave styling till the end? Or use components from beginning?  You can get burned by both.
*** react router
Rightly or wrongly, we have run =npx create vite= for the React Router variant, which I have never done.  React router demands some global thought.  We can be fancy with nest routes/shared header.
#+begin_src js :tangle ./app/routes.ts
import {
  type RouteConfig,
  route,
  index,
  layout,
} from "@react-router/dev/routes";

export default [
  layout("./layout.tsx", [
    route("login", "./login.tsx"),
    index("./search.tsx"),
    route("match", "./match.tsx"),
  ]),
] satisfies RouteConfig;
#+end_src
**** api/auth
We live in the future:
#+begin_quote
Given this info, generate an api.ts file with helper functions for everything. We expect the endpoint to be at =import.meta.env.VITE_API_ENDPOINT=.:
...
ROBOT: Here's a concise =api.ts= file with helper functions:

#+begin_src typescript :tangle
interface Dog {
    id: string;
    img: string;
#+end_quote

Only change here is that auth routes do not return json, so we cant assume that.
**** auth done
After some react router refresher, we are back.  Login, logout and protected routes are simple with actions.. just need to remember to do client action vs server where that makes sense.
#+begin_src typescript
// ta da
export async function clientAction({ request }: Route.ClientActionArgs) {
  const formData = await request.formData();
  const email = String(formData.get("email"));
  const name = String(formData.get("name"));
  if (!name || !email) {
    return { err: "Please enter both fields!" };
  }
  try {
    const res = await login(name, email);

    if (res.status === 200) {
      localStorage.setItem("dogmatch-user", name);
      return redirect("/");
    } else return { err: "Trouble logging in... Sorry about that!" };
  } catch (err) {
    return { err: "An API problem, hmmm " + err };
  }
}

export default function Login() {
  return (
    <div>
      <Form method="POST">
        <label htmlFor="name">Name:</label>
        <input type="text" name="name" />
        <label htmlFor="email">Email:</label>
        <input type="text" name="email" />
        <button type="submit">Login</button>
      </Form>
    </div>
  );
}
#+end_src
**** Moving on to search
Ideally, we do it the react router way but also have classic query params in the url.  So if we can get it with query params first, then we can just make the form.

...no I think we will just do it react/react-router way.  It will be fancier and its not reinventing anything.

This all follows naturally.  Pretty much got it but need to do pagination.
